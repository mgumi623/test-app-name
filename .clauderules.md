# Claude Code コーディング規約

このプロジェクトでコーディングする際に、Claude Codeが守るべき規約を定義します。

## 1. プロジェクト構造とファイル命名規則

### ファイル命名
- コンポーネントファイル: `PascalCase.tsx` (例: `ChatInterface.tsx`)
- フックファイル: `camelCase.ts` (例: `useChat.ts`)
- ユーティリティファイル: `camelCase.ts` (例: `validation.ts`)
- 型定義ファイル: `camelCase.ts` (例: `chat.ts`)

### ファイル構造
```typescript
/**
 * このファイルは[機能名]の[コンポーネント/フック/ユーティリティ]です。
 * 
 * 主な機能：
 * - [機能1]
 * - [機能2]
 * - [機能3]
 * 
 * 使用例：
 * ```typescript
 * import { ComponentName } from './ComponentName';
 * ```
 */
```

## 2. TypeScript型定義の厳格化

### 基本原則
- `any`型の使用を禁止
- すべての関数に戻り値の型を明示
- インターフェースは`PascalCase`で命名
- 型エイリアスは`PascalCase`で命名

### 型定義例
```typescript
interface ChatMessage {
  id: string;
  content: string;
  timestamp: Date;
  sender: 'user' | 'ai';
  attachments?: {
    type: 'image' | 'audio';
    url: string;
  }[];
}

type MessageStatus = 'sending' | 'sent' | 'error';
```

## 3. コンポーネント設計パターン

### Props型定義
```typescript
interface ComponentProps {
  // 必須プロパティ
  requiredProp: string;
  
  // オプショナルプロパティ
  optionalProp?: number;
  
  // コールバック関数
  onAction?: (data: ActionData) => void;
  
  // スタイリング
  className?: string;
  style?: React.CSSProperties;
}

// デフォルト値の設定
export default function Component({
  requiredProp,
  optionalProp = 0,
  onAction,
  className = "",
  style
}: ComponentProps) {
  // コンポーネント実装
}
```

### コンポーネント構造
1. インポート文
2. 型定義
3. コンポーネント定義
4. エクスポート

## 4. エラーハンドリングとバリデーション

### Zodスキーマによるバリデーション
```typescript
import { z } from 'zod';

const UserSchema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  password: z.string().min(8, 'パスワードは8文字以上で入力してください'),
  name: z.string().min(1, '名前は必須です')
});

const validateUser = (data: unknown) => {
  try {
    return UserSchema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new Error(`バリデーションエラー: ${error.errors.map(e => e.message).join(', ')}`);
    }
    throw error;
  }
};
```

### エラーハンドリング
```typescript
const handleAsyncOperation = async () => {
  try {
    const result = await someAsyncOperation();
    return result;
  } catch (error) {
    console.error('操作に失敗しました:', error);
    throw new Error('操作に失敗しました。しばらく時間をおいて再度お試しください。');
  }
};
```

## 5. Supabaseとの統合パターン

### 型安全なクライアント設定
```typescript
interface Database {
  public: {
    Tables: {
      [table_name]: {
        Row: {
          // テーブルの行の型定義
        };
        Insert: {
          // 挿入時の型定義
        };
        Update: {
          // 更新時の型定義
        };
      };
    };
  };
}

const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);
```

### クエリパターン
```typescript
const fetchData = async () => {
  const { data, error } = await supabase
    .from('table_name')
    .select('*')
    .eq('column', value);

  if (error) {
    throw new Error(`データの取得に失敗しました: ${error.message}`);
  }

  return data;
};
```

## 6. カスタムフックの設計

### フックの基本構造
```typescript
interface UseHookReturn {
  data: DataType;
  isLoading: boolean;
  error: string | null;
  actions: {
    action1: () => Promise<void>;
    action2: () => void;
  };
}

export function useCustomHook(param: string): UseHookReturn {
  const [data, setData] = useState<DataType>(initialValue);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 副作用の処理
  useEffect(() => {
    // 副作用の実装
  }, [param]);

  // アクション関数
  const action1 = async () => {
    // 実装
  };

  const action2 = () => {
    // 実装
  };

  return {
    data,
    isLoading,
    error,
    actions: {
      action1,
      action2
    }
  };
}
```

## 7. 環境変数とセキュリティ

### 環境変数の型安全な使用
```typescript
const requiredEnvVars = {
  SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  DIFY_API_KEY: process.env.DIFY_API_KEY,
} as const;

// 環境変数の存在チェック
Object.entries(requiredEnvVars).forEach(([key, value]) => {
  if (!value) {
    throw new Error(`必要な環境変数 ${key} が設定されていません`);
  }
});
```

### APIキーの安全な使用
```typescript
// サーバーサイドでのみ使用
const apiKey = process.env.SECRET_API_KEY;

// クライアントサイドで使用可能
const publicKey = process.env.NEXT_PUBLIC_API_KEY;
```

## 8. レスポンシブデザインとTailwind CSS

### クラス名の管理
```typescript
import { clsx } from 'clsx';

const buttonClasses = clsx(
  // 基本スタイル
  "px-4 py-2 rounded-md font-medium transition-colors",
  
  // 状態によるスタイル
  "bg-blue-500 text-white hover:bg-blue-600",
  "disabled:bg-gray-300 disabled:cursor-not-allowed",
  
  // サイズバリエーション
  "text-sm sm:text-base",
  
  // レスポンシブ対応
  "w-full sm:w-auto"
);
```

### コンポーネント固有のスタイル
```typescript
const cardVariants = {
  default: "bg-white border border-gray-200",
  elevated: "bg-white shadow-lg border-0",
  outlined: "bg-transparent border-2 border-gray-300"
} as const;

type CardVariant = keyof typeof cardVariants;
```

## 9. テスト可能なコード設計

### 依存性注入
```typescript
interface ServiceInterface {
  fetchData(): Promise<Data[]>;
  saveData(data: Data): Promise<void>;
}

export function useDataWithService(service: ServiceInterface) {
  // テスト時にモックサービスを注入可能
}
```

### 純粋関数の設計
```typescript
// 副作用のない純粋関数
export const formatMessage = (message: string, timestamp: Date): FormattedMessage => {
  return {
    content: message.trim(),
    formattedTime: timestamp.toLocaleString('ja-JP'),
    wordCount: message.split(' ').length
  };
};
```

## 10. アクセシビリティ対応

### 基本的なアクセシビリティ
```typescript
// ボタン要素
<button
  onClick={handleClick}
  aria-label="メッセージを送信"
  aria-describedby="message-input-description"
  disabled={isLoading}
  className="px-4 py-2 bg-blue-500 text-white rounded"
>
  {isLoading ? '送信中...' : '送信'}
</button>

// フォーム要素
<form onSubmit={handleSubmit} aria-labelledby="form-title">
  <h2 id="form-title">ユーザー情報入力</h2>
  <label htmlFor="email">メールアドレス</label>
  <input
    id="email"
    type="email"
    aria-required="true"
    aria-describedby="email-error"
  />
  <div id="email-error" role="alert" aria-live="polite">
    {emailError}
  </div>
</form>
```

### キーボードナビゲーション
```typescript
const handleKeyDown = (event: React.KeyboardEvent) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    handleSubmit();
  }
};
```

## 11. パフォーマンス最適化

### React.memoの使用
```typescript
const ExpensiveComponent = React.memo(({ data }: Props) => {
  // 重い処理を含むコンポーネント
  return <div>{/* レンダリング内容 */}</div>;
});
```

### useMemoとuseCallback
```typescript
const memoizedValue = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);

const memoizedCallback = useCallback(() => {
  handleAction(data);
}, [data, handleAction]);
```

## 12. コメントとドキュメント

### JSDocコメント
```typescript
/**
 * ユーザーメッセージを送信する関数
 * 
 * @param content - 送信するメッセージの内容
 * @param attachments - 添付ファイルの配列（オプション）
 * @returns 送信されたメッセージの情報
 * 
 * @example
 * ```typescript
 * const message = await sendMessage("こんにちは", [file]);
 * console.log(message.id);
 * ```
 */
export async function sendMessage(
  content: string,
  attachments?: File[]
): Promise<ChatMessage> {
  // 実装
}
```

## 13. エラーログとデバッグ

### 構造化されたログ
```typescript
const logger = {
  info: (message: string, data?: any) => {
    console.log(`[INFO] ${message}`, data);
  },
  error: (message: string, error?: Error) => {
    console.error(`[ERROR] ${message}`, error);
  },
  warn: (message: string, data?: any) => {
    console.warn(`[WARN] ${message}`, data);
  }
};
```

## 14. 国際化対応

### 多言語対応の準備
```typescript
const messages = {
  ja: {
    send: '送信',
    loading: '読み込み中...',
    error: 'エラーが発生しました'
  },
  en: {
    send: 'Send',
    loading: 'Loading...',
    error: 'An error occurred'
  }
} as const;

type Language = keyof typeof messages;
```

## 15. セキュリティベストプラクティス

### XSS対策
```typescript
// 危険なHTMLの挿入を避ける
const sanitizeHtml = (html: string): string => {
  // DOMPurifyなどのライブラリを使用
  return DOMPurify.sanitize(html);
};

// ReactではdangerouslySetInnerHTMLの使用を最小限に
<div dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />
```

### CSRF対策
```typescript
// APIリクエストでのCSRFトークン使用
const apiCall = async (data: any) => {
  const response = await fetch('/api/endpoint', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': getCsrfToken()
    },
    body: JSON.stringify(data)
  });
};
```

## 16. データベース設計とセキュリティ

### 🎯 設計方針
- **マルチテナント軸**: 各行は `hospital_id` でスコープ
- **ユーザー連動**: `auth.uid()` を中心に所属・権限を判定
- **セーフデフォルト**: RLSは `enable + force`、ポリシーが無い操作は拒否
- **インデックス先置き**: RLSの `using/exists` で参照する列にインデックス

### 📦 ファイル構成
```
scripts/
├── 01_helpers.sql      # 認可ヘルパー関数/ビュー/トリガ
├── 02_rls.sql          # 各テーブルのRLS（SELECT/INSERT/UPDATE/DELETE）
├── 03_grants.sql       # 権限（REVOKE/GRANT、RLS FORCE）
├── 04_indexes.sql      # ポリシーで使う列への索引
└── 99_tests.sql        # 想定成功/失敗パスの確認クエリ
```

### 🧩 ヘルパー関数（01_helpers.sql）
```sql
-- 自分の有効な病院所属
create or replace view v_current_memberships as
select m.user_id, m.hospital_id
from public.user_hospital_memberships m
where m.user_id = auth.uid()
  and m.is_enabled
  and now() >= m.valid_from
  and (m.valid_to is null or now() < m.valid_to);

-- 病院メンバー判定
create or replace function fn_is_member(h uuid) returns boolean
language sql stable as $$
  select exists(select 1 from v_current_memberships where hospital_id = h);
$$;

-- ロール判定（global/hospital）
create or replace function fn_has_role(role_code text, h uuid default null)
returns boolean language sql stable as $$
  with my_roles as (
    select r.code, ra.scope, ra.hospital_id
    from public.role_assignments ra
    join public.roles r on r.id = ra.role_id
    where ra.user_id = auth.uid()
  )
  select exists(
    select 1 from my_roles
     where code = role_code
       and (scope = 'global' or (scope = 'hospital' and hospital_id = coalesce(h, hospital_id)))
  );
$$;

-- 病院管理者のショートハンド
create or replace function fn_is_admin(h uuid) returns boolean
language sql stable as $$
  select fn_has_role('admin', h) or fn_has_role('platform_admin', null);
$$;

-- チャットセッション参加判定
create or replace function fn_is_session_member(sid uuid) returns boolean
language sql stable as $$
  select exists(select 1 from public.chat_session_members m
                 where m.session_id = sid and m.user_id = auth.uid())
      or exists(select 1 from public.chat_sessions s
                 where s.id = sid and s.user_id = auth.uid());
$$;
```

### 🛡️ RLSテンプレート（02_rls.sql）
```sql
-- 病院直下テーブル
alter table hospitals enable row level security;
alter table hospitals force row level security;

drop policy if exists sel_hospitals on hospitals;
create policy sel_hospitals on hospitals
for select using (exists (select 1 from v_current_memberships m where m.hospital_id = id));

drop policy if exists wrt_hospitals on hospitals;
create policy wrt_hospitals on hospitals
for all using (fn_is_admin(id)) with check (fn_is_admin(id));

-- hospital_id を持つマスタ
alter table positions enable row level security;
alter table positions force row level security;

drop policy if exists sel_positions on positions;
create policy sel_positions on positions
for select using (fn_is_member(hospital_id));

drop policy if exists wrt_positions on positions;
create policy wrt_positions on positions
for all using (fn_is_admin(hospital_id)) with check (fn_is_admin(hospital_id));

-- チャットセッション
alter table chat_sessions enable row level security;
alter table chat_sessions force row level security;

drop policy if exists sel_chat_sessions on chat_sessions;
create policy sel_chat_sessions on chat_sessions
for select using (
  fn_is_member(hospital_id)
  and (user_id = auth.uid() or fn_is_session_member(id))
);

drop policy if exists ins_chat_sessions on chat_sessions;
create policy ins_chat_sessions on chat_sessions
for insert with check (
  fn_is_member(hospital_id)
  and (app_id is null or fn_app_enabled_for_hospital(app_id, hospital_id))
);
```

### 🎁 権限設定（03_grants.sql）
```sql
-- 基本権限の取り消し
revoke all on all tables in schema public from public;
grant usage on schema public to postgres, anon, authenticated, service_role;

-- RLSが守る前提でアプリロールへ付与
grant select, insert, update, delete on all tables in schema public to authenticated;

-- すべてのテーブルで RLS を強制
do $$ declare r record; begin
  for r in select table_name from information_schema.tables
           where table_schema='public' and table_type='BASE TABLE'
  loop
    execute format('alter table public.%I enable row level security;', r.table_name);
    execute format('alter table public.%I force row level security;', r.table_name);
  end loop;
end $$;
```

### ⚡ インデックス（04_indexes.sql）
```sql
-- 病院スコープ（必須）
create index if not exists idx_hospital_id on table_name(hospital_id);

-- チャット関連
create index if not exists idx_chat_messages_session_created 
  on chat_messages(session_id, created_at);
create index if not exists idx_chat_session_members_session_user 
  on chat_session_members(session_id, user_id);

-- 所属・権限
create index if not exists idx_user_hospital_memberships_user_hospital 
  on user_hospital_memberships(user_id, hospital_id, is_enabled, valid_from, valid_to);

-- 役割
create index if not exists idx_role_assignments_user_hospital 
  on role_assignments(user_id, hospital_id);

-- アプリ有効化
create index if not exists idx_hospital_apps_hospital_app 
  on hospital_apps(hospital_id, app_id, is_enabled);
```

### 🧪 テスト（99_tests.sql）
```sql
-- メンバー/非メンバー/病院管理者/プラットフォーム管理者の各ロールで
-- SELECT/INSERT/UPDATE/DELETE の成功/失敗を確認

-- 例：病院メンバーのみが病院情報を閲覧可能
select * from hospitals where id = 'hospital-uuid'; -- expect: ok (メンバー) / deny (非メンバー)

-- チャットセッション参加者のみがメッセージを閲覧・投稿可能
select * from chat_messages where session_id = 'session-uuid'; -- expect: ok (参加者) / deny (非参加者)

-- ログは INSERT できるが SELECT 制限
insert into audit_logs (action, table_name, record_id) values ('SELECT', 'hospitals', 'uuid'); -- expect: ok
select * from audit_logs; -- expect: deny (管理者以外)
```

### ❌ やってはいけない
- スキーマの破壊的変更（カラム削除/型変更）
- RLS無効化や force の外し
- SECURITY DEFINER の濫用（必要最小）

### ✍️ スタイル
- 説明コメントを必ず付与（なぜこのRLSか）
- すべて再実行安全（idempotent）
- 迷ったら deny by default。速さより安全。安全が速さを生む。

### TypeScriptでのDB操作
```typescript
// 型安全なSupabaseクエリ
interface Database {
  public: {
    Tables: {
      chat_sessions: {
        Row: {
          id: string;
          hospital_id: string;
          user_id: string;
          title: string;
          created_at: string;
        };
        Insert: {
          hospital_id: string;
          user_id: string;
          title: string;
        };
        Update: {
          title?: string;
        };
      };
    };
  };
}

// クエリパターン
const fetchChatSessions = async (hospitalId: string) => {
  const { data, error } = await supabase
    .from('chat_sessions')
    .select('*')
    .eq('hospital_id', hospitalId);

  if (error) {
    throw new Error(`チャットセッションの取得に失敗しました: ${error.message}`);
  }

  return data;
};
```

---

## 適用方法

1. 新しいコードを書く際は、この規約に従ってください
2. 既存のコードを修正する際も、可能な限りこの規約に合わせてください
3. 規約に従わない場合は、明確な理由をコメントで説明してください
4. 定期的にコードレビューで規約の遵守状況を確認してください

この規約は、プロジェクトの成長に合わせて継続的に改善していきます。
